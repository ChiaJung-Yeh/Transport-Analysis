[["資料清洗與處理.html", "Chapter 2 資料清洗與處理 2.1 data.frame 與 data.table 2.2 合併資料 2.3 選取資料欄位 2.4 依條件篩選資料 2.5 新增資料屬性 2.6 條件判斷 2.7 資料排序 2.8 資料分群與統計 2.9 連接資料 2.10 重新命名欄位 2.11 去除重複資料 2.12 資料集合 2.13 資料型態轉換", " Chapter 2 資料清洗與處理 資料清洗與處理是分析前的第一步，透過此一步驟可初步觀察資料的趨勢，並以圖表呈現敘述統計結果。此外，在經過完善的資料整理後，尚能進一步建構統計模型或數據分析工具以瞭解資料背後所衍伸之意涵。dplyr與data.table套件是 R 語言中兩大最常見的資料處理工具，請務必安裝並導入該套件。 資料清洗與處理常用之套件與函式彙整如表2.1。 表 2.1: 資料處理重要函式 套件 函式 功能 base merge() 根據指定欄位連接兩資料 dplyr bind_rows() 合併橫列 bind_cols() 合併直行 select() 選取特定欄位 filter() 根據條件篩選資料 mutate() 新增資料屬性（直行） group_by() 將資料依據特定欄位分群` summarise() 將分群的資料予以計算 reframe() 將分群的資料予以計算 slice() 依據分群擷取特定資料 left_join() 根據指定欄位連接兩資料（僅保留左側資料） inner_join() 根據指定欄位連接兩資料（擁有的資料皆須保留） full_join() 根據指定欄位連接兩資料（僅保留共同擁有的資料） arrange() 根據指定欄位將資料排序 rename() 更改欄位名稱 distinct() 去除重複資料 intersect() 尋找兩資料中共同擁有的資料列（交集） union() 保留所有擁有的資料列（聯集，去除重複者） union_all() 保留所有擁有的資料列（聯集，保留重複者） setdiff() 尋找唯獨左側資料擁有的資料列（差集） symdiff() 尋找唯獨其中一份資料擁有的資料列（互斥） setequal() 檢查兩資料是否完全相同（無論排序） case_when() 條件判斷 data.table setDT() 將資料轉換為data.table形式 setkey() 設定data.table資料的主鍵 rbindlist() 合併陣列中的所有資料 merge.data.table() 連接資料 dcast() 轉換長資料為寬資料 melt() 轉換寬資料為長資料 為展示「資料清洗與處理」過程，後續範例中我們會使用的資料如下，請先讀取之。 # 世界國家資料 world=read.csv(&quot;https://raw.githubusercontent.com/ChiaJung-Yeh/Transport-Analysis/master/Data/world.csv&quot;) # 咖啡產量資料 coffee=read.csv(&quot;https://raw.githubusercontent.com/ChiaJung-Yeh/Transport-Analysis/master/Data/coffee.csv&quot;) 世界國家資料（world）中詳記各國資訊，包括人口數（pop）、面積（area_km2）、lifeExp（壽命）、gdpPerCap（人均 GDP）等；咖啡（coffee）資料中詳記世界各國 2016 與 2017 年的咖啡產量。 2.1 data.frame 與 data.table dplyr與data.table套件所提供的各函式大多功能皆相同，惟使用data.table套件的函式時，必須將資料型別新增 data.table 之格式，尚能正確分析。此外，data.table套件的執行效率通常較高，在大數據處理上極具優勢（依據實務經驗而論，若處理的資料筆數上達千萬筆，建議使用data.table套件），而若數據量較小時兩者的速度不相上下。關於兩資料分析套件的速度比較請參考以下文章： Comparing Efficiency and Speed of data.table data.table speed with dplyr syntax ⌾ 新增 data.table 資料格式 若欲針對原 data.frame 新增 data.table 之資料格式，可利用setDT()函式新增之，以world資料為例，程式碼撰寫如下。 # 使用read.csv()讀取資料 -&gt; data.frame() world_DT=read.csv(&quot;https://raw.githubusercontent.com/ChiaJung-Yeh/Transport-Analysis/master/Data/world.csv&quot;) # 查看資料型態 class(world_DT) ## [1] &quot;data.frame&quot; # setDT()函式新增data.table格式 setDT(world_DT) # 再次查看資料型態 class(world_DT) ## [1] &quot;data.table&quot; &quot;data.frame&quot; 由最後輸出結果可知，world_DT資料經過setDT()函式設定後即新增 data.table 格式，同時亦會保留 data.frame 格式。 ⌾ 新增主鍵 主鍵是資料中用以標示「關鍵的」屬性欄位，「關鍵」意謂該欄位具有唯一性，可以用其檢索整份資料，不會重複匹配至多比不同的資料。舉例而言，在考生成績的資料中，我們會利用學生的學號、姓名等作為主鍵，因為其具有代表性，可以表示特定資料；然而，我們不會利用學生的分數作為主鍵，因為分數值很可能是重複的，無法表示特定一筆資料。 根據上述，在 data.table 的資料格式中，主鍵是相當關鍵的要素，亦為使data.table套件效率甚高的其一原因。以world_DT資料為例，將「name_long」（國家名稱）設定為主鍵，函式撰寫如下。 # 建立主鍵 setDT(world_DT, name_long) 2.2 合併資料 ⌾ 合併欄與列 在第一章節中，我們曾提及資料框的行列合併，包含rbind()與cbind()兩函式，而dplyr套件所提供的bind_rows()與bind_cols()其目的相同，前者用以合併橫列；後者用以合併直行。其中bind_cols()與cbind()兩者功能完全相同。惟rbind()函式的使用前提是，輸入的兩資料必須擁有完全相同的欄位，一旦其中一個欄位不符合即無法合併資料。bind_rows()函式則可較彈性合併資料，針對共同擁有的欄位予以合併，其他則忽略之。具體範例如下。 # 建立兩資料 score_data1=data.frame(Student=c(&quot;Robert&quot;, &quot;Jessie&quot;, &quot;Rose&quot;, &quot;John&quot;), Class=c(&quot;A&quot;, &quot;B&quot;, &quot;D&quot;, &quot;C&quot;), Score=c(&quot;80&quot;, &quot;95&quot;, &quot;70&quot;, &quot;65&quot;)) score_data2=data.frame(Student=c(&quot;Penny&quot;, &quot;Ruby&quot;, &quot;Tom&quot;), Score=c(&quot;90&quot;, &quot;70&quot;, &quot;50&quot;)) rbind(score_data1, score_data2) ## Error in rbind(deparse.level, ...): 變數的行數無效 由以上rbind()函式之範例可知，由於score_data1含有「Class」欄位，而score_data2並不包含，故無法成功合併兩資料。此時可嘗試利用bind_rows()函式，程式碼撰寫如下。 bind_rows(score_data1, score_data2) ## Student Class Score ## 1 Robert A 80 ## 2 Jessie B 95 ## 3 Rose D 70 ## 4 John C 65 ## 5 Penny &lt;NA&gt; 90 ## 6 Ruby &lt;NA&gt; 70 ## 7 Tom &lt;NA&gt; 50 輸出結果中，score_data2雖並無「Class」欄位，仍可將兩資料予以合併，並在缺失的資料中填補NA。 ⌾ 合併儲存於陣列中的資料 在data.table套件中另提供rbindlist()函式，可將儲存於陣列中的所有資料予以合併，程式碼撰寫如下。惟使用此函式時，必須確保陣列中所有資料的欄位名稱一致。 data_list=list(data.frame(Var1=c(1:5), Var2=c(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;)), data.frame(Var1=c(6:10), Var2=c(&quot;F&quot;,&quot;G&quot;,&quot;H&quot;,&quot;I&quot;,&quot;J&quot;))) # 查看data_list陣列 data_list #合併所有陣列中的資料 rbindlist(data_list) 2.3 選取資料欄位 在第一章節中，我們曾提及資料框選取欄位的方法，而dplyr套建亦提供相同功能的select()函式，函式撰寫如下。 select(資料, 欄位名稱1, 欄位名稱2, ...) ⌾ 選取欄位 以選取world資料中的「name_long」和「area_km2」兩欄位為例，程式碼撰寫如下。 # 選取name_long與area_km2兩欄位 world_sel1=select(world, name_long, area_km2) # 查看前六筆資料 head(world_sel1) ## name_long area_km2 ## 1 Fiji 19289.97 ## 2 Tanzania 932745.79 ## 3 Western Sahara 96270.60 ## 4 Canada 10036042.98 ## 5 United States 9510743.74 ## 6 Kazakhstan 2729810.51 使用data.table套件選取欄位 world_DT[, .(name_long, area_km2)] 其他寫法包括（請回顧選取欄位章節）： # 給定欄位索引 world[, c(1,7)] # 給定欄位名稱 world[, c(&quot;name_long&quot;, &quot;area_km2&quot;)] # 回傳單一欄位 world$name_long world$area_km2 此外，亦可將欲返回的欄位儲存於一文字向量中，並透過all_of()函式回傳之，程式碼撰寫如下。 # 選取name_long與area_km2兩欄位 sel_col_name=c(&quot;name_long&quot;, &quot;continent&quot;, &quot;subregion&quot;) # 使用all_of()函式 world_sel2=select(world, all_of(sel_col_name)) # 查看前六筆資料 head(world_sel2) ## name_long continent subregion ## 1 Fiji Oceania Melanesia ## 2 Tanzania Africa Eastern Africa ## 3 Western Sahara Africa Northern Africa ## 4 Canada North America Northern America ## 5 United States North America Northern America ## 6 Kazakhstan Asia Central Asia 使用data.table套件選取欄位 world_DT[, ..sel_col_name] ⌾ 刪除欄位 若欲刪除特定欄位，可利用-在欄位名稱前即可刪除之。 # 刪除continent、region_un、subregion、type欄位 world_sel3=select(world, -continent, -region_un, -subregion, -type) # 查看前六筆資料 head(world_sel3) ## iso_a2 name_long area_km2 pop lifeExp gdpPercap ## 1 FJ Fiji 19289.97 885806 69.96000 8222.254 ## 2 TZ Tanzania 932745.79 52234869 64.16300 2402.099 ## 3 EH Western Sahara 96270.60 NA NA NA ## 4 CA Canada 10036042.98 35535348 81.95305 43079.143 ## 5 US United States 9510743.74 318622525 78.84146 51921.985 ## 6 KZ Kazakhstan 2729810.51 17288285 71.62000 23587.338 使用data.table套件刪除欄位 del_col_name=c(&quot;continent&quot;,&quot;region_un&quot;,&quot;subregion&quot;,&quot;type&quot;) world_DT[, !..del_col_name] 2.4 依條件篩選資料 條件篩選資料可以利用filter()函式達成之，函式撰寫如下。 filter(資料, 條件1, 條件2, ...) 以上條件1與條件2是用以篩選資料中符合條件者，最終所回傳的資料必然符合函式內所有的條件。 ⌾ 數值向量篩選 以篩選world資料中，人口數（pop）超過 1 億人者。 # 篩選人口數超過1億的資料 world_fil1=filter(world, pop&gt;100000000) # 查看前六筆資料 head(world_fil1) ## iso_a2 name_long continent region_un subregion ## 1 US United States North America Americas Northern America ## 2 ID Indonesia Asia Asia South-Eastern Asia ## 3 RU Russian Federation Europe Europe Eastern Europe ## 4 MX Mexico North America Americas Central America ## 5 BR Brazil South America Americas South America ## 6 NG Nigeria Africa Africa Western Africa ## type area_km2 pop lifeExp gdpPercap ## 1 Country 9510743.7 318622525 78.84146 51921.985 ## 2 Sovereign country 1819251.3 255131116 68.85600 10003.089 ## 3 Sovereign country 17018507.4 143819666 70.74366 25284.586 ## 4 Sovereign country 1969480.3 124221600 76.75300 16622.597 ## 5 Sovereign country 8508557.1 204213133 75.04200 15374.262 ## 6 Sovereign country 905071.7 176460502 52.54900 5671.901 # 查看查看符合條件的總資料筆數（亦即國家數） nrow(world_fil1) ## [1] 12 使用data.table套件篩選資料 world_DT[pop&gt;100000000] ⌾ 文字向量篩選 通常文字篩選時會利用%in%以查看一向量各元素是否存在於另一向量中，請參照向量 Vector小節中「⌾ 檢查元素是否包含於向量」。 以篩選world資料中，所在洲隸屬於亞洲（Asia）以及歐洲（Europe）者。 # filter data by population world_fil2=filter(world, continent %in% c(&quot;Asia&quot;, &quot;Europe&quot;)) # check out the first 6 rows head(world_fil2) ## iso_a2 name_long continent region_un subregion ## 1 KZ Kazakhstan Asia Asia Central Asia ## 2 UZ Uzbekistan Asia Asia Central Asia ## 3 ID Indonesia Asia Asia South-Eastern Asia ## 4 RU Russian Federation Europe Europe Eastern Europe ## 5 NO Norway Europe Europe Northern Europe ## 6 TL Timor-Leste Asia Asia South-Eastern Asia ## type area_km2 pop lifeExp gdpPercap ## 1 Sovereign country 2729810.51 17288285 71.62000 23587.338 ## 2 Sovereign country 461410.26 30757700 71.03900 5370.866 ## 3 Sovereign country 1819251.33 255131116 68.85600 10003.089 ## 4 Sovereign country 17018507.41 143819666 70.74366 25284.586 ## 5 Sovereign country 397994.63 NA NA NA ## 6 Sovereign country 14714.93 1212814 68.28500 6262.906 使用data.table套件篩選資料 world_DT[continent %in% c(&quot;Asia&quot;, &quot;Europe&quot;)] ⌾ 多重條件篩選（AND） 在filter()函式中所設定的諸多條件皆須滿足尚會進一步保留資料。以world資料為例，篩選洲隸屬於亞洲以及歐洲，且人口數超過 1 億者。程式碼撰寫如下。 # 依條件篩選資料 world_fil3=filter(world, continent %in% c(&quot;Asia&quot;, &quot;Europe&quot;), pop&gt;100000000) # 查看前六筆資料 head(world_fil3) ## iso_a2 name_long continent region_un subregion ## 1 ID Indonesia Asia Asia South-Eastern Asia ## 2 RU Russian Federation Europe Europe Eastern Europe ## 3 IN India Asia Asia Southern Asia ## 4 BD Bangladesh Asia Asia Southern Asia ## 5 PK Pakistan Asia Asia Southern Asia ## 6 CN China Asia Asia Eastern Asia ## type area_km2 pop lifeExp gdpPercap ## 1 Sovereign country 1819251.3 255131116 68.85600 10003.089 ## 2 Sovereign country 17018507.4 143819666 70.74366 25284.586 ## 3 Sovereign country 3142892.1 1293859294 68.02100 5385.142 ## 4 Sovereign country 133782.1 159405279 71.80300 2973.042 ## 5 Sovereign country 874120.0 185546257 66.13900 4576.227 ## 6 Country 9409830.5 1364270000 75.93200 12758.648 # 查看查看符合條件的總資料筆數（亦即國家數） nrow(world_fil3) ## [1] 8 除可以直接以「逗號」分隔各項條件外，亦可利用「&amp;」串接所有條件，程式碼撰寫如下。 # 利用&amp;串接所有條件 world_fil4=filter(world, continent %in% c(&quot;Asia&quot;, &quot;Europe&quot;) &amp; pop&gt;100000000) 使用data.table套件篩選資料 world_DT[continent %in% c(&quot;Asia&quot;, &quot;Europe&quot;) &amp; pop&gt;100000000] ⌾ 多重條件（OR） filter()函式係需要所有條件皆滿足尚會回傳資料，然而有時我們希望其一條件成立即可，此時可以將各項條件以「|」分開，程式碼撰寫如下。 # 滿足其一條建篩選資料 world_fil5=filter(world, continent %in% c(&quot;Asia&quot;, &quot;Europe&quot;) | pop&gt;100000000) # 查看查看符合條件的總資料筆數（亦即國家數） nrow(world_fil5) ## [1] 90 使用data.table套件篩選資料 world_DT[continent %in% c(&quot;Asia&quot;, &quot;Europe&quot;) | pop&gt;100000000] 2.5 新增資料屬性 前面所提及的cbind()與bind_cols()函式可以將欄位予以合併，藉此擴充資料屬性。此外，於第一章節中所提及的向量「$」亦可新增資料屬性。除以上寫法外，可利用dplyr套件中的mutate()函式擴增資料屬性，且操作更具有彈性。函式撰寫如下。 mutate(資料, 新變數1=..., 新變數2=..., ...) ⌾ 新增資料屬性 以world資料為例，新增「各國人口密度(pop_dens)」之欄位（人口密度即總人口數除以面積），並新增一欄位串接 continent 和 subregion（使用paste0()函式串接向量）。程式碼撰寫如下。 # 新增人口密度屬性 world_mut=mutate(world, pop_dens=pop/area_km2, district=paste0(continent, &quot; (&quot;, subregion, &quot;)&quot;)) # 查看前六筆資料 head(world_mut[, c(&quot;name_long&quot;, &quot;area_km2&quot;, &quot;pop&quot;, &quot;pop_dens&quot;)]) ## name_long area_km2 pop pop_dens ## 1 Fiji 19289.97 885806 45.920547 ## 2 Tanzania 932745.79 52234869 56.001184 ## 3 Western Sahara 96270.60 NA NA ## 4 Canada 10036042.98 35535348 3.540773 ## 5 United States 9510743.74 318622525 33.501326 ## 6 Kazakhstan 2729810.51 17288285 6.333145 使用data.table套件新增資料屬性 # 新增一個變數時 world_mut=world_DT[, pop_dens := pop/area_km2] # 新增多個變數時 world_mut=world_DT[, c(&quot;pop_dens&quot;, &quot;district&quot;) := .(pop/area_km2, paste0(continent, &quot; (&quot;, subregion, &quot;)&quot;))] 由以上程式碼可知，透過data.table套件新增欄位時，須利用「:=」定義運算方式，並將新增的欄位名稱置於其左側，而運算過程則放置於右側。 其他寫法如下（請回顧擴增資料欄（新增屬性）小節）： # 利用$直接新增欄位 world$pop_dens=world$pop/world$area_km2 world$district=paste0(world$continent, &quot; (&quot;, world$subregion, &quot;)&quot;) 2.6 條件判斷 ⌾ 使用ifelse()函式判斷 於前一章中有提及「邏輯判斷」的流程控制方法，其中ifelse()函式可大幅縮減程式碼。在此亦可透過mutate()函式搭配ifelse()函式建立邏輯判斷的結果。以world資料為例，新增一欄位判斷國家面積的大小，若國家面積大於整體資料中位數，標記為「L」；否則記錄為「S」。程式碼撰寫如下。 # 先計算面積中位數 area_med=median(world$area_km2) # 利用ifelse函式判斷類群 world_ifel=mutate(world, TYPE=ifelse(area_km2&gt;=area_med, &quot;L&quot;, &quot;S&quot;)) # 查看六筆資料 head(world_ifel[, c(&quot;name_long&quot;, &quot;area_km2&quot;, &quot;TYPE&quot;)]) ## name_long area_km2 TYPE ## 1 Fiji 19289.97 S ## 2 Tanzania 932745.79 L ## 3 Western Sahara 96270.60 S ## 4 Canada 10036042.98 L ## 5 United States 9510743.74 L ## 6 Kazakhstan 2729810.51 L ⌾ 使用case_when()函式判斷 ifelse()函式較適合應用於單純的邏輯判斷，若涉及多項判斷式可能須建立巢狀迴圈，使程式碼變得甚為複雜。此時我們可應用dplyr套件中的case_when()函式，並同樣搭配mutate()函式以新增欄位。case_when()函式撰寫架構如下： case_when(欄位, 條件1 ~ 結果1, 條件2 ~ 結果2, TRUE ~ 結果3, ...) 其中的「TRUE」意謂著若前面所有條件皆「不成立」時，則回傳TRUE賦予的結果。 再次以world資料為例，若欲將所有國家依據面積及人口數予以分類，並藉由中位數劃分數值高低，最後分為「面積大人口多（LALP）」、「面積大人口少（LASP）」、「面積小人口多（SALP）」與「面積小人口少（SASP）」四者。程式碼撰寫如下。 # 先計算面積與人口數中位數 area_med=median(world$area_km2) pop_med=median(world$pop, na.rm=T) # 由於人口數中含有NA值，故設定na.rm=T以移除NA值後再計算 # 使用case_when()函式新增分類 world_casewhen=mutate(world, TYPE=case_when( area_km2&gt;=area_med &amp; pop&gt;=pop_med ~ &quot;LALP&quot;, area_km2&gt;=area_med &amp; pop&lt;pop_med ~ &quot;LASP&quot;, area_km2&lt;area_med &amp; pop&gt;=pop_med ~ &quot;SALP&quot;, TRUE ~ &quot;SASP&quot; )) # 查看六筆資料 head(world_casewhen[, c(&quot;name_long&quot;, &quot;area_km2&quot;, &quot;pop&quot;, &quot;TYPE&quot;)]) ## name_long area_km2 pop TYPE ## 1 Fiji 19289.97 885806 SASP ## 2 Tanzania 932745.79 52234869 LALP ## 3 Western Sahara 96270.60 NA SASP ## 4 Canada 10036042.98 35535348 LALP ## 5 United States 9510743.74 318622525 LALP ## 6 Kazakhstan 2729810.51 17288285 LALP 2.7 資料排序 ⌾ 資料排序（正序） 在第一章節中我們提及許多排序的方法，包含向量排序（sort()、order()、rank()）與文字排序（str_sort()、str_order()）。而在此我們可以進一步藉由dplyr套件中的arrange()函式排序資料，其函式撰寫架構如下。 arrange(資料, 待排序欄位) 以world資料為例，若欲將所有國家依人口數由少至多排列，程式碼撰寫如下。 world_arr1=arrange(world, pop) # 查看前六筆資料 head(world_arr1[, c(&quot;name_long&quot;, &quot;continent&quot;, &quot;pop&quot;)]) ## name_long continent pop ## 1 Greenland North America 56295 ## 2 Vanuatu Oceania 258850 ## 3 New Caledonia Oceania 268050 ## 4 Iceland Europe 327386 ## 5 Belize North America 351694 ## 6 Bahamas North America 382169 使用data.table套件排序 函式架構： 資料[order(待排序欄位)] 以world資料，依人口數由少至多排列為例，程式碼撰寫如下 world_DT[order(pop)] ⌾ 資料排序（倒序） 須注意的是arrange()函式預設為由小到大（正序）排列，故若欲「倒序」排列，可在待排序欄位引數前面加上「-」即可，抑或使用desc(待排序欄位)函式。以world資料依人口數由多至少排列為例，程式碼撰寫如下。 world_arr2=arrange(world, -pop) # 或使用desc()函式倒序排列 world_arr2=arrange(world, desc(pop)) # 查看前六筆資料 head(world_arr2[, c(&quot;name_long&quot;, &quot;continent&quot;, &quot;pop&quot;)]) ## name_long continent pop ## 1 China Asia 1364270000 ## 2 India Asia 1293859294 ## 3 United States North America 318622525 ## 4 Indonesia Asia 255131116 ## 5 Brazil South America 204213133 ## 6 Pakistan Asia 185546257 使用data.table套件倒序排列資料 world_DT[order(-pop)] 2.8 資料分群與統計 ⌾ 將資料依據特定欄位分群 group_by(資料, 分群欄位) 利用group_by()函式分群後，資料並不會有任何變化，必須再搭配其他函式才能發揮分群的效果。 ⌾ 分群篩選資料（filter()） 透過分群篩選資料，可篩選各群組符合條件者，函式撰寫架構如下。 group_by(資料, 分群欄位)%&gt;% filter(條件) 以world資料為例，先將資料依據洲（continent）分群，而後篩選出各洲資料中面積最大者，程式碼撰寫如下。 world_gro1=group_by(world, continent)%&gt;% filter(area_km2==max(area_km2)) # 查看資料 world_gro1[, c(&quot;continent&quot;,&quot;name_long&quot;,&quot;area_km2&quot;)] ## # A tibble: 8 × 3 ## # Groups: continent [8] ## continent name_long area_km2 ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 North America Canada 10036043. ## 2 Africa Democratic Republic of the Congo 2323492. ## 3 Europe Russian Federation 17018507. ## 4 Seven seas (open ocean) French Southern and Antarctic Lands 11603. ## 5 South America Brazil 8508557. ## 6 Oceania Australia 7687614. ## 7 Asia China 9409830. ## 8 Antarctica Antarctica 12335956. ⌾ 分群篩選資料（slice()） slice()函式用以回傳指定條件的索引值，故搭配group_by()時可以篩選各分群中的指定橫列位。函式撰寫架構如下。 group_by(資料, 分群欄位)%&gt;% slice(索引值) 舉例而言，若欲回傳world資料中各分群內的第一筆資料，程式碼撰寫如下。 world_gro2=group_by(world, continent)%&gt;% slice(1) # 查看資料 world_gro2[, c(&quot;continent&quot;,&quot;name_long&quot;,&quot;area_km2&quot;,&quot;pop&quot;,&quot;lifeExp&quot;,&quot;gdpPercap&quot;)] ## # A tibble: 8 × 6 ## # Groups: continent [8] ## continent name_long area_km2 pop lifeExp gdpPercap ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Africa Tanzania 9.33e5 5.22e7 64.2 2402. ## 2 Antarctica Antarctica 1.23e7 NA NA NA ## 3 Asia Kazakhstan 2.73e6 1.73e7 71.6 23587. ## 4 Europe Russian Federation 1.70e7 1.44e8 70.7 25285. ## 5 North America Canada 1.00e7 3.55e7 82.0 43079. ## 6 Oceania Fiji 1.93e4 8.86e5 70.0 8222. ## 7 Seven seas (open ocean) French Southern an… 1.16e4 NA NA NA ## 8 South America Argentina 2.78e6 4.30e7 76.3 18798. 使用data.table套件分群統計 函式架構： 資料[, .SD[索引值], by=分群欄位] 回傳world資料中各分群內的第一筆資料。 world_DT[, .SD[1], by=continent] 此外，亦可擷取多個索引值的資料，舉例而言，若欲回傳world資料中各分群內的第一筆與最後一筆資料，程式碼撰寫如下。 world_gro3=group_by(world, continent)%&gt;% slice(1, n()) # 查看資料 world_gro3[, c(&quot;continent&quot;,&quot;name_long&quot;)] ## # A tibble: 16 × 2 ## # Groups: continent [8] ## continent name_long ## &lt;chr&gt; &lt;chr&gt; ## 1 Africa Tanzania ## 2 Africa South Sudan ## 3 Antarctica Antarctica ## 4 Antarctica Antarctica ## 5 Asia Kazakhstan ## 6 Asia Cyprus ## 7 Europe Russian Federation ## 8 Europe Kosovo ## 9 North America Canada ## 10 North America Trinidad and Tobago ## 11 Oceania Fiji ## 12 Oceania Australia ## 13 Seven seas (open ocean) French Southern and Antarctic Lands ## 14 Seven seas (open ocean) French Southern and Antarctic Lands ## 15 South America Argentina ## 16 South America Paraguay 使用data.table套件分群統計 回傳world資料中各分群（洲）內的第一筆與最後一筆資料，程式碼撰寫如下。 world_DT[, .SD[c(1, .N)], by=continent] 上述程式碼中的.N意同dplyr套件中的n()。 group_by() %&gt;% slice()函式亦可與arrange()函式結合，以擷取排序後特定序位的資料。再以world資料為例，若欲擷取每個洲前三大面積的國家，可以先利用arrange()函式將所有資料依據面積（area_km2）排列，而後再透過group_by() %&gt;% slice()函式擷取需要的索引值（即1:3）。程式碼撰寫如下。 world_gro4=arrange(world, desc(area_km2))%&gt;% group_by(continent)%&gt;% slice(1:3) # 查看資料 world_gro4[, c(&quot;continent&quot;,&quot;name_long&quot;,&quot;area_km2&quot;,&quot;pop&quot;,&quot;lifeExp&quot;,&quot;gdpPercap&quot;)] ## # A tibble: 20 × 6 ## # Groups: continent [8] ## continent name_long area_km2 pop lifeExp gdpPercap ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Africa Democratic Republ… 2.32e6 7.37e7 58.8 785. ## 2 Africa Algeria 2.32e6 3.91e7 75.6 13483. ## 3 Africa Sudan 1.85e6 3.77e7 64.0 4188. ## 4 Antarctica Antarctica 1.23e7 NA NA NA ## 5 Asia China 9.41e6 1.36e9 75.9 12759. ## 6 Asia India 3.14e6 1.29e9 68.0 5385. ## 7 Asia Kazakhstan 2.73e6 1.73e7 71.6 23587. ## 8 Europe Russian Federation 1.70e7 1.44e8 70.7 25285. ## 9 Europe France 6.45e5 NA NA NA ## 10 Europe Ukraine 5.73e5 4.53e7 71.2 8243. ## 11 North America Canada 1.00e7 3.55e7 82.0 43079. ## 12 North America United States 9.51e6 3.19e8 78.8 51922. ## 13 North America Greenland 2.21e6 5.63e4 NA NA ## 14 Oceania Australia 7.69e6 2.35e7 82.3 43547. ## 15 Oceania Papua New Guinea 4.65e5 7.76e6 65.2 3709. ## 16 Oceania New Zealand 2.78e5 4.51e6 81.4 34455. ## 17 Seven seas (open ocean) French Southern a… 1.16e4 NA NA NA ## 18 South America Brazil 8.51e6 2.04e8 75.0 15374. ## 19 South America Argentina 2.78e6 4.30e7 76.3 18798. ## 20 South America Peru 1.31e6 3.10e7 74.5 11548. 使用data.table套件分群統計 回傳world資料中各分群（洲）面積前三大的資料，程式碼撰寫如下。 world_DT[order(-area_km2)]%&gt;% .[, .SD[c(1:3)], by=continent] 與dplyr套件的撰寫方式相同，若欲串接不同的函式，可透過 pipe (%&gt;%) 連接。另外請注意此回傳結果會保留所有匹配與未匹配的資料，例如world_DT資料中 Antarctica 僅有一個區域，而由於我們尋找前六筆資料，此函式會回傳所有六筆結果，未匹配者則在其他筆資料中顯示NA。 group_by() %&gt;% filter()函式無法透過多個條件設定，回傳符合各個不同條件的資料。然而實務上有時候希望擷取滿足多個不同條件的資料，此時可以利用group() %&gt;% slice()達成目的。 以world資料為例，先將資料依據洲（continent）分群，而後篩選出各洲資料中面積最大與最小者，程式碼撰寫如下。 world_gro5=group_by(world, continent)%&gt;% slice(which.max(area_km2), which.min(area_km2)) # 查看所有資料 world_gro5[, c(&quot;continent&quot;,&quot;name_long&quot;,&quot;area_km2&quot;)] ## # A tibble: 16 × 3 ## # Groups: continent [8] ## continent name_long area_km2 ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Africa Democratic Republic of the Congo 2323492. ## 2 Africa The Gambia 14031. ## 3 Antarctica Antarctica 12335956. ## 4 Antarctica Antarctica 12335956. ## 5 Asia China 9409830. ## 6 Asia Northern Cyprus 3786. ## 7 Europe Russian Federation 17018507. ## 8 Europe Luxembourg 2417. ## 9 North America Canada 10036043. ## 10 North America Trinidad and Tobago 7738. ## 11 Oceania Australia 7687614. ## 12 Oceania Vanuatu 7490. ## 13 Seven seas (open ocean) French Southern and Antarctic Lands 11603. ## 14 Seven seas (open ocean) French Southern and Antarctic Lands 11603. ## 15 South America Brazil 8508557. ## 16 South America Falkland Islands 16364. 以上程式碼中which.max()函式用以尋找最大值的索引；which.min()則尋找最小值之索引。此時利用group_by() %&gt;% slice()函式可同時回傳符合不同特定條件者。綜上所述，group_by() %&gt;% slice()函式的使用上相當具彈性。 使用data.table套件分群統計 回傳world資料中各分群（洲）面積最大與最小的資料，程式碼撰寫如下。 world_DT[, .SD[c(which.min(area_km2), which.max(area_km2))], by=continent] ⌾ 分群統計資料（summarise()） 分群統計資料可針對各群組內的欄位做運算，如最大值、最小值、加總、平均…等，抑或使用自定義函式。分群統計資料的函式撰寫架構如下。 group_by(資料, 分群欄位)%&gt;% summarise(運算函式) 以world資料為例，先將資料依據洲（continent）分群，而後統計各洲總人口數與國家數，程式碼撰寫如下。 world_gro6=group_by(world, continent)%&gt;% summarise(pop=sum(pop, na.rm=T), County_N=n()) # 輸出資料 world_gro6 ## # A tibble: 8 × 3 ## continent pop County_N ## &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; ## 1 Africa 1154946633 51 ## 2 Antarctica 0 1 ## 3 Asia 4311408059 47 ## 4 Europe 669036256 39 ## 5 North America 565028684 18 ## 6 Oceania 37757833 7 ## 7 Seven seas (open ocean) 0 1 ## 8 South America 412060811 13 請注意於本範例中由於總人口數（pop）欄位中含有部分 NA，故為避免計算結果有誤，須在sum()函式中設定na.rm=T引數。此外，由輸出結果可發現，有別於group_by() %&gt;% filter()函式會回傳所有的資料欄位，group_by() %&gt;% summarise()函式僅回傳指定的統計資料欄位。另外n()函式表示計算各分群內的總資料筆數。 使用data.table套件分群統計 函式架構： 資料[, .(運算函式), by=分群欄位] 回傳world資料中各分群（洲）總人口數與國家個數。 world_DT[, .(pop=sum(pop, na.rm=T), County_N=.N), by=continent] ⌾ 分群統計資料（reframe()） 除了group_by() %&gt;% summarise()以外，亦可使用group_by() %&gt;% reframe()達到相同目的，且適用的彈性更大。如以上的範例，group_by() %&gt;% summarise()回傳的是統計後的結果，通常運算函式僅回傳一個值，如sum()是針對所有群組內的特定變數做加總。然而有時候運算函式可能並非單純回傳一個值，例如range()函式回傳的是兩個值，包括最小值與最大值，此時使用group_by() %&gt;% summarise()雖能得到結果，但會出現警告訊息，而使用group_by() %&gt;% reframe()則可在無警告之下得到正確結果。group_by() %&gt;% reframe()的函式撰寫架構如下，與group_by() %&gt;% summarise()相同。 group_by(資料, 分群欄位)%&gt;% reframe(運算函式) 再次以world資料為例，將資料依據洲（continent）分群，而後統計各洲人均 GDP（gdpPercap）的範圍，程式碼撰寫如下。 world_gro7=group_by(world, continent)%&gt;% reframe(gdpPercap=range(gdpPercap, na.rm=T)) # 輸出資料 world_gro7 ## # A tibble: 16 × 2 ## continent gdpPercap ## &lt;chr&gt; &lt;dbl&gt; ## 1 Africa 597. ## 2 Africa 31543. ## 3 Antarctica Inf ## 4 Antarctica -Inf ## 5 Asia 1839. ## 6 Asia 120860. ## 7 Europe 4763. ## 8 Europe 93655. ## 9 North America 1653. ## 10 North America 51922. ## 11 Oceania 2140. ## 12 Oceania 43547. ## 13 Seven seas (open ocean) Inf ## 14 Seven seas (open ocean) -Inf ## 15 South America 6325. ## 16 South America 22195. 由以上程式碼可知各洲人均 GDP 的範圍。另須注意的是，由於「Antarctica」中所有國家並無人均 GDP 的資料，故回傳之上下界為 Inf 與 -Inf。 使用data.table套件分群統計 回傳world資料中各分群（洲）總人口數與國家個數，程式碼撰寫如下。 world_DT[, .(pop=sum(pop, na.rm=T), County_N=.N), by=continent] 2.9 連接資料 cbind與bind_cols()函式是將兩份相同橫列數的資料直接予以合併，以連結兩份資料。不過在資料分析時，我們往往會有許多來源與目的不同的資料，而若希望將其合併，則必須依據「參照欄位」貼附。具體而論，world資料中記錄世界各國的詳細資訊，而coffee資料中則記錄世界各國的咖啡產量，若我們想同時知道各國的面積與咖啡產量，勢必需要將這兩份資料合併在一起，而合併的原則須依據「國家名稱」以貼附資料。 在dplyr套件中可以利用join相關函式，包括left_join()、full_join()與inner_join()。 left_join()是只保留第一份（左側）所有資料，並依據參照欄位貼附第二份（右側）資料；full_join()是指所有兩份資料皆須保留，並進一步依據參照欄位相互貼附；inner_join()則是指保留兩份資料共同擁有的參照欄位，並依此相互貼附。 在base套件中與在data.table套件中，無論是何種形式的連接資料方式，皆可分別利用merge()與merge.data.table()函式達成目的，其中可透過設定引數（all=與all.x=）之方式決定連接資料的方式。 關於連接資料的概念詳見圖2.1之示意圖，而以上三套件連接資料的函式彙整如表2.2。 圖 2.1: join 示意圖 表 2.2: 連接資料函式彙整 資料連接方式 dplyr套件 base套件 data.table套件 以第一份（左側）資料為基準 left_join(資料1, 資料2) merge(資料1, 資料2, all.x=T) merge.data.table(資料1, 資料2, all.x=T) 保留資料1與資料2所有資料 full_join(資料1, 資料2) merge(資料1, 資料2, all=T) merge.data.table(資料1, 資料2, all=T) 保留共同擁有的參照欄位之資料 inner_join(資料1, 資料2) merge(資料1, 資料2) merge.data.table(資料1, 資料2) ⌾ 以第一份（左側）資料為基準 left_join()的函式撰寫架構如下。 left_join(資料1, 資料2, by=&quot;參照欄位&quot;) 函式中的by=引數用以設定「參照欄位」，亦即若兩份資料的參照欄位內容是相同者，便將資料2的欄位貼附於資料1後。left_join()函式是保留資料1的所有資料，故若參照欄位的內容於資料2找不到相對應者，則該列貼附的結果會直接回傳「NA」。 另外需注意的是，by=引數可以不用設定，而此時該函式預設在兩份資料中尋找所有相同欄位名稱者作為參照欄位。而若兩份資料內欲參照的欄位名稱不相同時，引數設定須為by=c(資料1參照欄位=資料2參照欄位)。若有多個參照欄位，各欄位的名稱須以向量表達，如by=c(\"參照欄位1\", \"參照欄位2\")。 以學生資料（StuInfo）與學生分數紀錄（StuScore）作為範例，程式碼撰寫如下。 # 建立學生資料與分數資料 StuInfo=data.frame(StudentID=c(&quot;ID1&quot;,&quot;ID2&quot;,&quot;ID3&quot;,&quot;ID4&quot;,&quot;ID5&quot;,&quot;ID6&quot;), Class=c(&quot;A&quot;,&quot;B&quot;,&quot;A&quot;,&quot;C&quot;,&quot;D&quot;,&quot;A&quot;), Name=c(&quot;Bob&quot;,&quot;Mary&quot;,&quot;Robert&quot;,&quot;Jason&quot;,&quot;Jane&quot;,&quot;Jessie&quot;)) StuScore=data.frame(StudentID=c(&quot;ID1&quot;,&quot;ID2&quot;,&quot;ID4&quot;,&quot;ID5&quot;,&quot;ID6&quot;,&quot;ID7&quot;), Score=c(60,80,40,50,100,90)) # 連接兩份資料 left_join(StuInfo, StuScore, by=&quot;StudentID&quot;) ## StudentID Class Name Score ## 1 ID1 A Bob 60 ## 2 ID2 B Mary 80 ## 3 ID3 A Robert NA ## 4 ID4 C Jason 40 ## 5 ID5 D Jane 50 ## 6 ID6 A Jessie 100 以上程式碼中by=\"StudentID\"即為兩份資料的共同參照欄位，由於兩參照欄位正好名稱相同，故若未設定此一引數亦可。另外從回傳結果可發現，由於資料 1（StuInfo）中並無學生代碼「ID7」，故該欄位的資料 2（StuScore）屬性皆為NA。 使用base與data.table套件連接資料 在此二套件中，若連接方式為「以第一份（左側）資料為基準」，必須設定引數all.x=T。函式中的by=引數用以設定「參照欄位」，而若兩資料的參照欄位名稱不同時，需進一步設定by.x=與by.y=兩引數，分別為左側資料的參照欄位名稱與右側資料的欄位名稱。函式撰寫架構如下： # 若兩資料的參照欄位名稱不同 merge(資料1, 資料2, all.x=T, by=&quot;參照欄位&quot;) merge.data.table(資料1, 資料2, all.x=T, by=&quot;參照欄位&quot;) # 若兩資料的參照欄位名稱不同 merge(資料1, 資料2, all.x=T, by.x=&quot;資料1參照欄位&quot;, by.y=&quot;資料2參照欄位&quot;) merge.data.table(資料1, 資料2, all.x=T, by.x=&quot;資料1參照欄位&quot;, by.y=&quot;資料2參照欄位&quot;) 以連接StuInfo與StuScore兩資料為例，參照欄位為「StudentID」。 StuInfo_DT=data.table(StudentID=c(&quot;ID1&quot;,&quot;ID2&quot;,&quot;ID3&quot;,&quot;ID4&quot;,&quot;ID5&quot;,&quot;ID6&quot;), Class=c(&quot;A&quot;,&quot;B&quot;,&quot;A&quot;,&quot;C&quot;,&quot;D&quot;,&quot;A&quot;), Name=c(&quot;Bob&quot;,&quot;Mary&quot;,&quot;Robert&quot;,&quot;Jason&quot;,&quot;Jane&quot;,&quot;Jessie&quot;)) StuScore_DT=data.table(StudentID=c(&quot;ID1&quot;,&quot;ID2&quot;,&quot;ID4&quot;,&quot;ID5&quot;,&quot;ID6&quot;,&quot;ID7&quot;), Score=c(60,80,40,50,100,90)) # base套件 merge(StuInfo, StuScore, all.x=T, by=&quot;StudentID&quot;) # data.table套件 merge.data.table(StuInfo_DT, StuScore_DT, all.x=T, by=&quot;StudentID&quot;) 利用前述world與coffee兩資料，依據國家名稱相連接為例，在world資料中貼附各國咖啡的產量。程式碼撰寫如下。 # 合併world與coffee兩資料 world_coffee=left_join(world, coffee, by=&quot;name_long&quot;) # 將world_coffee依據coffee_production_2017由大至小排序 world_coffee=arrange(world_coffee, desc(coffee_production_2017)) # 查看前六筆資料 head(world_coffee[, c(&quot;name_long&quot;,&quot;continent&quot;,&quot;coffee_production_2016&quot;,&quot;coffee_production_2017&quot;)]) ## name_long continent coffee_production_2016 coffee_production_2017 ## 1 Brazil South America 3277 2786 ## 2 Vietnam Asia 1844 1700 ## 3 Colombia South America 1330 1169 ## 4 Peru South America 585 625 ## 5 India Asia 453 566 ## 6 Uganda Africa 408 443 請注意由於此範例中，world資料內的國家名稱欄位與coffee資料內的國家名稱相同，皆為「name_long」，故若不設定by=引數，亦可得到相同結果。 ⌾ 保留資料1與資料2所有資料 full_join()的函式撰寫架構與前述left_join()函式完全相同。 再次以StuInfo與StuScore兩資料為例，利用full_join()所得結果如下。 full_join(StuInfo, StuScore, by=&quot;StudentID&quot;) ## StudentID Class Name Score ## 1 ID1 A Bob 60 ## 2 ID2 B Mary 80 ## 3 ID3 A Robert NA ## 4 ID4 C Jason 40 ## 5 ID5 D Jane 50 ## 6 ID6 A Jessie 100 ## 7 ID7 &lt;NA&gt; &lt;NA&gt; 90 由以上結果可知，兩份資料中所有的「StudentID」皆會保留，而無法匹配資料者，顯示NA。例如「ID3」在StuScore中無紀錄；「ID7」在StuInfo中無紀錄，故配對後其他欄位的資料即顯示NA。 使用base與data.table套件連接資料 若連接方式為「保留資料1與資料2所有資料」，必須設定引數all=T，而其他引數之設定方式與前者相同。函式撰寫架構如下： merge(資料1, 資料2, all=T, by=&quot;參照欄位&quot;) merge.data.table(資料1, 資料2, all=T, by=&quot;參照欄位&quot;) 以連接StuInfo與StuScore兩資料為例，參照欄位為「StudentID」。 # base套件 merge(StuInfo, StuScore, all=T, by=&quot;StudentID&quot;) # data.table套件 merge.data.table(StuInfo_DT, StuScore_DT, all=T, by=&quot;StudentID&quot;) ⌾ 保留共同擁有的參照欄位之資料 inner_join()的函式撰寫架構亦與前述left_join()函式完全相同。 再次以StuInfo與StuScore兩資料為例，利用inner_join()所得結果如下。 inner_join(StuInfo, StuScore, by=&quot;StudentID&quot;) ## StudentID Class Name Score ## 1 ID1 A Bob 60 ## 2 ID2 B Mary 80 ## 3 ID4 C Jason 40 ## 4 ID5 D Jane 50 ## 5 ID6 A Jessie 100 由以上結果可知，兩份資料中所有的「StudentID」僅會保留共同擁有的紀錄，而無法匹配資料者逕予以刪除。例如「ID3」在StuScore中無紀錄；「ID7」在StuInfo中無紀錄，故配對後即刪除此二筆資料。 使用base與data.table套件連接資料 若連接方式為「保留共同擁有的參照欄位之資料」，無須設定all=或all.x=之引數。函式撰寫架構如下： merge(資料1, 資料2, by=&quot;參照欄位&quot;) merge.data.table(資料1, 資料2, by=&quot;參照欄位&quot;) 以連接StuInfo與StuScore兩資料為例，參照欄位為「StudentID」。 # base套件 merge(StuInfo, StuScore, by=&quot;StudentID&quot;) # data.table套件 merge.data.table(StuInfo_DT, StuScore_DT, by=&quot;StudentID&quot;) 2.10 重新命名欄位 在第一章節中提及設定資料欄位名稱的方法，可藉由colnames()設定或修改欄位名稱。此外dplyr套件中的rename()函式亦可指定修改名稱的欄位，並賦予新名稱。函式撰寫架構如下。 rename(資料, 新欄位名稱=舊欄位名稱) 以修改StuScore資料的名稱為例，程式碼撰寫如下。 StuInfo_rn1=rename(StuInfo, STUID=StudentID, CLASS=Class) StuInfo_rn1 ## STUID CLASS Name ## 1 ID1 A Bob ## 2 ID2 B Mary ## 3 ID3 A Robert ## 4 ID4 C Jason ## 5 ID5 D Jane ## 6 ID6 A Jessie 此外，亦可利用rename_with()函式，使修改名稱的方式更有所彈性，其函式撰寫架構如下。 rename_with(資料, 修正函式) 再以StuScore資料為例，若欲將所有欄位名稱修正為全大寫字母，程式碼撰寫如下。 StuInfo_rn2=rename_with(StuInfo, toupper) StuInfo_rn2 ## STUDENTID CLASS NAME ## 1 ID1 A Bob ## 2 ID2 B Mary ## 3 ID3 A Robert ## 4 ID4 C Jason ## 5 ID5 D Jane ## 6 ID6 A Jessie 除可設定既有的函式外，亦可藉由自定義函式修正之，例如若我們希望所有名稱都接上「_A」，則程式碼撰寫如下。 # 建立自定義函式 paste_A=function(x){ return(paste0(x, &quot;_A&quot;)) } # 修正名稱，全部欄位名稱加上「_A」 StuInfo_rn3=rename_with(StuInfo, paste_A) StuInfo_rn3 ## StudentID_A Class_A Name_A ## 1 ID1 A Bob ## 2 ID2 B Mary ## 3 ID3 A Robert ## 4 ID4 C Jason ## 5 ID5 D Jane ## 6 ID6 A Jessie 而若希望有條件式的修正欄位名稱，則可利用.cols=引數設定需要更動的欄位索引值。以StuInfo資料為例，若欲針對欄位名稱具有「a」者，轉換為全大寫，程式碼撰寫如下。 StuInfo_rn4=rename_with(StuInfo, toupper, .cols=grep(&quot;a&quot;, colnames(StuInfo))) StuInfo_rn4 ## StudentID CLASS NAME ## 1 ID1 A Bob ## 2 ID2 B Mary ## 3 ID3 A Robert ## 4 ID4 C Jason ## 5 ID5 D Jane ## 6 ID6 A Jessie 以上程式碼中的colnames()函式用以回傳特定資料的名稱，grep()函式為尋找含括特定字元的元素索引值。 2.11 去除重複資料 在第一章節中我們提過可以利用unique()函式篩選出向量的唯一值，亦即將重複的元素予以去除。而若希望刪除重複的資料列，可利用distinct()函式，其撰寫架構如下。 distinct(資料) 以下範例演示distinct()函式的功能，同時利用duplicated函式先行檢查是否有重複的列。 # 建立具有重複資料的資料框 StuScore_dup=data.frame(StudentID=c(&quot;ID1&quot;,&quot;ID2&quot;,&quot;ID4&quot;,&quot;ID3&quot;,&quot;ID4&quot;,&quot;ID5&quot;,&quot;ID2&quot;), Name=c(&quot;Bob&quot;,&quot;Mary&quot;,&quot;Jason&quot;,&quot;Robert&quot;,&quot;Jason&quot;,&quot;Jane&quot;,&quot;Mary&quot;), Score=c(60,80,40,100,40,100,80)) # 檢查是否有重複列 duplicated(StuScore_dup) ## [1] FALSE FALSE FALSE FALSE TRUE FALSE TRUE # 去除重複列 distinct(StuScore_dup) ## StudentID Name Score ## 1 ID1 Bob 60 ## 2 ID2 Mary 80 ## 3 ID4 Jason 40 ## 4 ID3 Robert 100 ## 5 ID5 Jane 100 使用base套件去除重複資料 unique()函式不僅可去除向量內的重複元素，亦可去除資料框中的重複資料。 unique(StuScore_dup) 2.12 資料集合 資料集合包含交集（intersect）、聯集（union）、差集（difference）、對稱差集（symmetric difference），如圖2.2之示意圖所示。 圖 2.2: join 示意圖 ⌾ 交集 資料交集可利用intersect()函式，撰寫架構如下。其中資料1與資料2的欄位必須相同。 intersect(資料1, 資料2) 以新建資料data1與data2為例，程式碼撰寫如下。 # 建立資料 data1=data.frame(Var1=c(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;), Var2=c(1,2,3,4,5), Var3=c(T,F,T,F,T)) data2=data.frame(Var1=c(&quot;F&quot;,&quot;D&quot;,&quot;G&quot;,&quot;E&quot;,&quot;B&quot;), Var2=c(6,4,7,5,2), Var3=c(F,F,T,T,F)) # 交集 intersect(data1, data2) ## Var1 Var2 Var3 ## 1 B 2 FALSE ## 2 D 4 FALSE ## 3 E 5 TRUE 使用data.table套件取交集 data1_DT=data.table(Var1=c(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;), Var2=c(1,2,3,4,5), Var3=c(T,F,T,F,T)) data2_DT=data.table(Var1=c(&quot;F&quot;,&quot;D&quot;,&quot;G&quot;,&quot;E&quot;,&quot;B&quot;), Var2=c(6,4,7,5,2), Var3=c(F,F,T,T,F)) fintersect(data1_DT, data2_DT) ⌾ 聯集 資料聯集可利用union()函式，撰寫架構如下。其中資料1與資料2的欄位必須相同。另須注意的是，若資料中有重複者，union()函式會自動去除，若欲回傳所有重複資料，則可使用union_all()函式。 # 聯集（去除重複資料） union(資料1, 資料2) # 聯集（保留重複資料） union_all(資料1, 資料2) 以data1與data2資料為例，程式碼撰寫如下。 # 聯集 union(data1, data2) ## Var1 Var2 Var3 ## 1 A 1 TRUE ## 2 B 2 FALSE ## 3 C 3 TRUE ## 4 D 4 FALSE ## 5 E 5 TRUE ## 6 F 6 FALSE ## 7 G 7 TRUE 使用data.table套件取聯集 funion(data1_DT, data2_DT) ⌾ 差集 資料差集可利用setdiff()函式，撰寫架構如下。其中資料1與資料2的欄位必須相同。 setdiff(資料1, 資料2) 再此以data1與data2資料為例，程式碼撰寫如下。 # 差集 (data1-data2) setdiff(data1, data2) ## Var1 Var2 Var3 ## 1 A 1 TRUE ## 2 C 3 TRUE # 差集 (data2-data1) setdiff(data2, data1) ## Var1 Var2 Var3 ## 1 F 6 FALSE ## 2 G 7 TRUE 使用data.table套件取差集 fsetdiff(data1_DT, data2_DT) ⌾ 對稱差集 資料對稱差集可利用symdiff()函式，撰寫架構如下。其中資料1與資料2的欄位必須相同。 symdiff(資料1, 資料2) 以data1與data2資料為例，程式碼撰寫如下。 # 對稱差集 symdiff(data1, data2) ## Var1 Var2 Var3 ## 1 A 1 TRUE ## 2 C 3 TRUE ## 3 F 6 FALSE ## 4 G 7 TRUE ⌾ 檢查兩資料是否完全相同 若希望檢查兩資料是否完全相同，可透過setequal()函式檢查之，撰寫架構如下。 setequal(資料1, 資料2) 以data1與data2資料為例，程式碼撰寫如下。 # 對稱差集 setequal(data1, data2) ## [1] FALSE 使用data.table套件檢查兩資料是否完全相同 fsetequal(data1_DT, data2_DT) 2.13 資料型態轉換 "]]
