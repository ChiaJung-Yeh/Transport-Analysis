```{r setup1, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(data.table)
library(sf)
library(ggplot2)
library(ggsflabel)
library(ggspatial)
library(knitr)
library(kableExtra)
library(TDX)
library(DT)
library(stringr)
library(jsonlite)
library(xml2)

Sys.setlocale(category = "LC_ALL", locale = "zh_TW.UTF-8")

windowsFonts(A=windowsFont("微軟正黑體"))

client_id=read.csv("./key.txt", header=F)[1,2]
client_secret=read.csv("./key.txt", header=F)[2,2]
access_token=get_token(client_id, client_secret)
```

# **資料清洗與處理**
資料清洗與處理是分析前的第一步，透過此一步驟可初步觀察資料的趨勢，並以圖表呈現敘述統計結果。此外，在經過完善的資料整理後，尚能進一步建構統計模型或數據分析工具以瞭解資料背後所衍伸之意涵。`dplyr`與`data.table`套件是 R 語言中兩大最常見的資料處理工具，請務必安裝並導入該套件。

資料清洗與處理常用之套件與函式彙整如表\@ref(tab:function-data-clean)。  

```{r function-data-clean, echo=F, eval=T}
fuc=data.frame(Package=c("`base`", rep("`dplyr`", 22), rep("`data.table`", 4)), Functions=c("`merge()`","[`bind_rows()`](#合併資料)","[`bind_cols()`](#合併資料)","[`select()`](#選取資料欄位)","[`filter()`](#依條件篩選資料)","`mutate()`","`group_by()`","`summarise()`","`reframe()`","`slice()`","`left_join()`","`inner_join()`","`full_join()`","`arrange()`","`rename()`","`distinct()`","`intersect()`","`union()`","`union_all()`","`setdiff()`","`symdiff()`","`setequal()`","`case_when()`","[`setDT()`](#data.frame-與-data.table)","[`setkey()`](#data.frame-與-data.table)","`dcast()`","`melt()`"), Usage=c("根據指定欄位連接兩資料", "合併橫列", "合併直行", "選取特定欄位", "根據條件篩選資料", "新增資料屬性（直行）",  "將資料依據特定欄位分群`", "將分群的資料予以計算", "將分群的資料予以計算", "依據分群擷取特定資料", "根據指定欄位連接兩資料（僅保留左側資料）", "根據指定欄位連接兩資料（擁有的資料皆須保留）", "根據指定欄位連接兩資料（僅保留共同擁有的資料）", "根據指定欄位將資料排序", "更改欄位名稱", "去除重複資料", "尋找兩資料中共同擁有的資料列（交集）", "保留所有擁有的資料列（聯集，去除重複者）", "保留所有擁有的資料列（聯集，保留重複者）", "尋找唯獨左側資料擁有的資料列（差集）", "尋找唯獨其中一份資料擁有的資料列（互斥）", "檢查兩資料是否完全相同（無論排序）", "條件判斷", "將資料轉換為`data.table`形式", "設定`data.table`資料的主鍵", "轉換長資料為寬資料", "轉換寬資料為長資料"))

colnames(fuc)=c("套件","函式","功能")

kbl(fuc, booktabs=T, escape=F, caption="資料處理重要函式")%>%
  kable_styling(bootstrap_options=c("striped", "hover"), font_size=14)%>%
  collapse_rows(1)%>%
  row_spec(0, bold=T, color="white", background="#8E8E8E")
```


為展示「資料清洗與處理」過程，後續範例中我們會使用的資料如下，請先讀取之。

```{r read-data-world, echo=T, eval=T}
# 世界國家資料
world=read.csv("https://raw.githubusercontent.com/ChiaJung-Yeh/Transport-Analysis/master/Data/world.csv")
```

```{r read-data-world-show, echo=F, eval=T, message=F, warning=F}
datatable(world, options=list(pageLength=5, scrollX=T, headerCallback = DT::JS(
    "function(thead) {",
    "  $(thead).css('font-size', '0.7em');",
    "}"
  )))%>%
  formatStyle(columns=c(1:ncol(world)), fontSize='12px')%>%
  formatRound(c("area_km2", "lifeExp","gdpPercap"), digits=2)
```

```{r read-data-coffee, echo=T, eval=T}
# 咖啡產量資料
coffee=read.csv("https://raw.githubusercontent.com/ChiaJung-Yeh/Transport-Analysis/master/Data/coffee.csv")
```

```{r read-data-coffee-show, echo=F, eval=T, message=F, warning=F}
datatable(coffee, options=list(pageLength=5, scrollX=T, headerCallback = DT::JS(
    "function(thead) {",
    "  $(thead).css('font-size', '0.7em');",
    "}"
  )))%>%
  formatStyle(columns=c(1:ncol(coffee)), fontSize='12px')
```

世界國家資料（`world`）中詳記各國資訊，包括人口數（pop）、面積（area_km2）、lifeExp（壽命）、gdpPerCap（人均 GDP）等；咖啡（`coffee`）資料中詳記世界各國 2016 與 2017 年的咖啡產量。

## data.frame 與 data.table
`dplyr`與`data.table`套件所提供的各函式大多功能皆相同，惟使用`data.table`套件的函式時，必須將資料型別新增 data.table 之格式，尚能正確分析。此外，`data.table`套件的執行效率通常較高，在大數據處理上極具優勢（依據實務經驗而論，若處理的資料筆數上達千萬筆，建議使用`data.table`套件），而若數據量較小時兩者的速度不相上下。關於兩資料分析套件的速度比較請參考以下文章：

* [Comparing Efficiency and Speed of `data.table`](https://tysonbarrett.com/jekyll/update/2019/10/06/datatable_memory/)  
* [data.table speed with dplyr syntax](https://towardsdatascience.com/data-table-speed-with-dplyr-syntax-yes-we-can-51ef9aaed585)  


<p style="color:#003D79;font-size:18px;line-height:2">**⌾ 新增 data.table 資料格式**</p>  

若欲針對原 data.frame 新增 data.table 之資料格式，可利用`setDT()`函式新增之，以`world`資料為例，程式碼撰寫如下。

```{r read-data-world-dt, echo=T, eval=T}
# 使用read.csv()讀取資料 -> data.frame()
world_DT=read.csv("https://raw.githubusercontent.com/ChiaJung-Yeh/Transport-Analysis/master/Data/world.csv")

# 查看資料型態
class(world_DT)

# setDT()函式新增data.table格式
setDT(world_DT)

# 再次查看資料型態
class(world_DT)
```


由最後輸出結果可知，`world_DT`資料經過`setDT()`函式設定後即新增 data.table 格式，同時亦會保留 data.frame 格式。

<p style="color:#003D79;font-size:18px;line-height:2">**⌾ 新增主鍵**</p>  

主鍵是資料中用以標示「關鍵的」屬性欄位，「關鍵」意謂該欄位具有唯一性，可以用其檢索整份資料，不會重複匹配至多比不同的資料。舉例而言，在考生成績的資料中，我們會利用學生的學號、姓名等作為主鍵，因為其具有代表性，可以表示特定資料；然而，我們不會利用學生的分數作為主鍵，因為分數值很可能是重複的，無法表示特定一筆資料。

根據上述，在 data.table 的資料格式中，主鍵是相當關鍵的要素，亦為使`data.table`套件效率甚高的其一原因。以`world_DT`資料為例，將「name_long」（國家名稱）設定為主鍵，函式撰寫如下。

```{r data-world-dt-key, echo=T, eval=T}
# 建立主鍵
setDT(world_DT, name_long)
```


## 合併資料
在第一章節中，我們曾提及資料框的[行列合併](#資料框data-frame)，包含`rbind()`與`cbind()`兩函式，而`dplyr`套件所提供的`bind_rows()`與`bind_cols()`其目的相同，前者用以合併橫列；後者用以合併直行。其中`bind_cols()`與`cbind()`兩者功能完全相同。惟`rbind()`函式的使用前提是，輸入的兩資料必須擁有完全相同的欄位，一旦其中一個欄位不符合即無法合併資料。`bind_rows()`函式則可較彈性合併資料，針對共同擁有的欄位予以合併，其他則忽略之。具體範例如下。

```{r rbind-bindrow1, echo=T, eval=T, error=T}
# 建立兩資料
score_data1=data.frame(Student=c("Robert", "Jessie", "Rose", "John"),
                       Class=c("A", "B", "D", "C"),
                       Score=c("80", "95", "70", "65"))

score_data2=data.frame(Student=c("Penny", "Ruby", "Tom"),
                       Score=c("90", "70", "50"))

rbind(score_data1, score_data2)
```

由以上`rbind()`函式之範例可知，由於`score_data1`含有「Class」欄位，而`score_data2`並不包含，故無法成功合併兩資料。此時可嘗試利用`bind_rows()`函式，程式碼撰寫如下。

```{r rbind-bindrow2, echo=T, eval=T}
bind_rows(score_data1, score_data2)
```

輸出結果中，`score_data2`雖並無「Class」欄位，仍可將兩資料予以合併，並在缺失的資料中填補`NA`。


## 選取資料欄位
在第一章節中，我們曾提及資料框選取欄位的方法，而`dplyr`套建亦提供相同功能的`select()`函式，函式撰寫如下。

```{r select-code, echo=T, eval=F}
select(資料, 欄位名稱1, 欄位名稱2, ...)
```


<p style="color:#003D79;font-size:18px;line-height:2">**⌾ 選取欄位**</p>  
以選取`world`資料中的「name_long」和「area_km2」兩欄位為例，程式碼撰寫如下。

```{r select-eg1, echo=T, eval=T}
# 選取name_long與area_km2兩欄位
world_sel1=select(world, name_long, area_km2)

# 查看前六筆資料
head(world_sel1)
```

<p style="color:#750000;">使用`data.table`套件選取欄位，程式碼撰寫如下。</p>  

```{r select-eg1-dt, echo=T, eval=F}
world_DT[, .(name_long, area_km2)]
```


其他寫法包括（請回顧[選取欄位](#資料框data-frame)章節）：

```{r select-eg2, echo=T, eval=F}
# 給定欄位索引
world[, c(1,7)]

# 給定欄位名稱
world[, c("name_long", "area_km2")]

# 回傳單一欄位
world$name_long
world$area_km2
```

此外，亦可將欲返回的欄位儲存於一文字向量中，並透過`all_of()`函式回傳之，程式碼撰寫如下。

```{r select-eg3, echo=T, eval=T}
# 選取name_long與area_km2兩欄位
sel_col_name=c("name_long", "continent", "subregion")

# 使用all_of()函式
world_sel2=select(world, all_of(sel_col_name))

# 查看前六筆資料
head(world_sel2)
```

<p style="color:#750000;">使用`data.table`套件選取欄位，程式碼撰寫如下。</p>  

```{r select-eg3-dt, echo=T, eval=F}
world_DT[, ..sel_col_name]
```


<p style="color:#003D79;font-size:18px;line-height:2">**⌾ 刪除欄位**</p>  

若欲刪除特定欄位，可利用`-`在欄位名稱前即可刪除之。

```{r select-eg4, echo=T, eval=T}
# 刪除continent、region_un、subregion、type欄位
world_sel3=select(world, -continent, -region_un, -subregion, -type)

# 查看前六筆資料
head(world_sel3)
```

<p style="color:#750000;">使用`data.table`套件刪除欄位，程式碼撰寫如下。</p>  

```{r select-eg4-dt, echo=T, eval=F}
del_col_name=c("continent","region_un","subregion","type")
world_DT[, !..del_col_name]
```



## 依條件篩選資料
條件篩選資料可以利用`filter()`函式達成之，函式撰寫如下。

```{r filter-code, echo=T, eval=F}
filter(資料, 條件1, 條件2, ...)
```

以上`條件1`與`條件2`是用以篩選資料中符合條件者，最終所回傳的資料必然符合函式內**所有**的條件。

<p style="color:#003D79;font-size:18px;line-height:2">**⌾ 數值向量篩選**</p>  

以篩選`world`資料中，人口數（`pop`）超過 1 億人者。

```{r filter-eg1, echo=T, eval=T}
# 篩選人口數超過1億的資料
world_fil1=filter(world, pop>100000000)

# 查看前六筆資料
head(world_fil1)

# 查看查看符合條件的總資料筆數（亦即國家數）
nrow(world_fil1)
```

<p style="color:#750000;">使用`data.table`套件篩選資料，程式碼撰寫如下。</p>  

```{r filter-eg1-dt, echo=T, eval=F}
world_DT[pop>100000000]
```


<p style="color:#003D79;font-size:18px;line-height:2">**⌾ 文字向量篩選**</p>  
通常文字篩選時會利用`%in%`以查看一向量各元素是否存在於另一向量中，請參照[向量 Vector](#向量vector)小節中「⌾ 檢查元素是否包含於向量」。
  
以篩選`world`資料中，所在洲隸屬於亞洲（Asia）以及歐洲（Europe）者。

```{r filter-eg2, echo=T, eval=T}
# filter data by population
world_fil2=filter(world, continent %in% c("Asia", "Europe"))

# check out the first 6 rows
head(world_fil2)
```

<p style="color:#750000;">使用`data.table`套件篩選資料，程式碼撰寫如下。</p>  

```{r filter-eg2-dt, echo=T, eval=F}
world_DT[continent %in% c("Asia", "Europe")]
```


<p style="color:#003D79;font-size:18px;line-height:2">**⌾ 多重條件篩選（AND）**</p>  

在`filter()`函式中所設定的諸多條件皆須滿足尚會進一步保留資料。以`world`資料為例，篩選洲隸屬於亞洲以及歐洲，且人口數超過 1 億者。程式碼撰寫如下。

```{r filter-eg3, echo=T, eval=T}
# 依條件篩選資料
world_fil3=filter(world, continent %in% c("Asia", "Europe"), pop>100000000)

# 查看前六筆資料
head(world_fil3)

# 查看查看符合條件的總資料筆數（亦即國家數）
nrow(world_fil3)
```

除可以直接以「逗號」分隔各項條件外，亦可利用「`&`」串接所有條件，程式碼撰寫如下。

```{r filter-eg4, echo=T, eval=F}
# 利用&串接所有條件
world_fil4=filter(world, continent %in% c("Asia", "Europe") & pop>100000000)
```

<p style="color:#750000;">使用`data.table`套件篩選資料，程式碼撰寫如下。</p>  

```{r filter-eg4-dt, echo=T, eval=F}
world_DT[continent %in% c("Asia", "Europe") & pop>100000000]
```


<p style="color:#003D79;font-size:18px;line-height:2">**⌾ 多重條件（OR）**</p>  

`filter()`函式係需要所有條件皆滿足尚會回傳資料，然而有時我們希望其一條件成立即可，此時可以將各項條件以「`|`」分開，程式碼撰寫如下。

```{r filter-eg5, echo=T, eval=T}
# 滿足其一條建篩選資料
world_fil5=filter(world, continent %in% c("Asia", "Europe") | pop>100000000)

# 查看查看符合條件的總資料筆數（亦即國家數）
nrow(world_fil5)
```

<p style="color:#750000;">使用`data.table`套件篩選資料，程式碼撰寫如下。</p>  

```{r filter-eg5-dt, echo=T, eval=F}
world_DT[continent %in% c("Asia", "Europe") | pop>100000000]
```


## 新增資料屬性
前面所提及的[`cbind()`與`bind_cols()`函式](#合併資料)可以將欄位予以合併，藉此擴充資料屬性。此外，於第一章節中所提及的向量「`$`」亦可新增資料屬性。除以上寫法外，可利用`dplyr`套件中的`mutate()`函式擴增資料屬性，且操作更具有彈性。函式撰寫如下。

```{r mutate-code, echo=T, eval=F}
mutate(資料, 新變數1=..., 新變數2=..., ...)
```

<p style="color:#003D79;font-size:18px;line-height:2">**⌾ 新增資料屬性**</p>  
以`world`資料為例，新增「各國人口密度(pop_dens)」之欄位（人口密度即總人口數除以面積），並新增一欄位串接 continent 和 subregion（使用[`paste0()`](#連接字串)函式串接向量）。程式碼撰寫如下。

```{r mutate-eg1, echo=T, eval=T}
# 新增人口密度屬性
world_mut=mutate(world, pop_dens=pop/area_km2,
                 district=paste0(continent, " (", subregion, ")"))

# 查看前六筆資料
head(world_mut[, c("name_long", "area_km2", "pop", "pop_dens")])
```

<p style="color:#750000;">使用`data.table`套件新增資料屬性，程式碼撰寫如下。</p>  

```{r mutate-eg2, echo=T, eval=F}
# 新增一個變數時
world_mut=world_DT[, pop_dens := pop/area_km2]

# 新增多個變數時
world_mut=world_DT[, c("pop_dens", "district") := .(pop/area_km2, paste0(continent, " (", subregion, ")"))]
```

由以上程式碼可知，透過`data.table`套件新增欄位時，須利用「`:=`」定義運算方式，並將新增的欄位名稱置於其左側，而運算過程則放置於右側。

其他寫法如下（請回顧[擴增資料欄（新增屬性）](#資料框data-frame)小節）：

```{r mutate-eg3, echo=T, eval=F}
# 利用$直接新增欄位
world$pop_dens=world$pop/world$area_km2
world$district=paste0(world$continent, " (", world$subregion, ")")
```


## 條件判斷
於前一章中有提及「邏輯判斷(#邏輯判斷)」的流程控制方法，其中`ifelse()`函式可大幅縮減程式碼。在此亦可透過`mutate()`函式搭配`ifelse()`函式建立邏輯判斷的結果。以`world`資料為例，新增一欄位判斷國家面積的大小，若國家面積大於整體資料中位數，標記為「L」；否則記錄為「S」。程式碼撰寫如下。

```{r ifelse-eg1, echo=T, eval=F}
# 先計算面積中位數
area_med=median(world$area_km2)

# 利用ifelse函式判斷類群
world_ifel=mutate(world, TYPE=ifelse(area_km2>=area_med, "L", "S"))

# 查看六筆資料
head(world_ifel[, c("name_long", "area_km2", "TYPE")])
```

`ifelse()`函式較適合應用於單純的邏輯判斷，若涉及多項判斷式可能須因而建立巢狀迴圈，使程式碼變得甚為複雜。此時我們可應用`dplyr`套件中的`case_when()`函式，同樣搭配`mutate()`函式以新增欄位。`case_when()`函式撰寫架構如下：

```{r case-when-code, echo=T, eval=F}
case_when(欄位, 
          條件1 ~ 結果1, 
          條件2 ~ 結果2, 
          TRUE ~ 結果3,
          ...)
```

其中的「`TRUE`」意謂著若前面所有條件皆「不成立」時，則回傳`TRUE`賦予的結果。

再次以`world`資料為例，若欲將所有國家依據面積及人口數予以分類，並藉由中位數劃分數值高低，最後分為「面積大人口多（LALP）」、「面積大人口少（LASP）」、「面積小人口多（SALP）」與「面積小人口少（SASP）」四者。程式碼撰寫如下。

```{r case-when-eg1, echo=T, eval=F}
# 先計算面積與人口數中位數
area_med=median(world$area_km2)
pop_med=median(world$pop, na.rm=T) # 由於人口數中含有NA值，故設定na.rm=T以移除NA值後再計算

# 使用case_when()函式新增分類
world_casewhen=mutate(world, TYPE=case_when(
  area_km2>=area_med & pop>=pop_med ~ "LALP",
  area_km2>=area_med & pop<pop_med ~ "LASP",
  area_km2<area_med & pop>=pop_med ~ "SALP",
  TRUE ~ "SASP"
))

# 查看六筆資料
head(world_casewhen[, c("name_long", "area_km2", "pop", "TYPE")])
```


## 資料分群與統計




## 連接資料



## 資料排序




## 去除重複資料




## 資料集合






## 資料型態轉換





